name: Deploy

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: staging
    concurrency: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push Docker images
      run: |
        # Build and push all service images
        for service in api web jobs; do
          docker build \
            --file infra/dockerfiles/Dockerfile.$service \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/emr-$service:staging \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/emr-$service:${{ github.sha }} \
            --push \
            .
        done

    - name: Deploy to staging server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ secrets.STAGING_PORT }}
        script: |
          # Update deployment configuration
          cd /opt/emr-platform
          
          # Pull latest images
          docker compose --profile staging pull
          
          # Update environment variables
          echo "IMAGE_TAG=staging" > .env.staging
          echo "DEPLOYMENT_ENV=staging" >> .env.staging
          
          # Deploy with zero downtime
          docker compose --profile staging up -d --remove-orphans
          
          # Wait for services to be healthy
          sleep 30
          
          # Health check
          curl -f http://localhost:8080/healthz || exit 1
          curl -f http://localhost:3000/api/health || exit 1
          
          # Clean up old images
          docker image prune -f

    - name: Run staging tests
      run: |
        # Run integration tests against staging environment
        export STAGING_URL=${{ secrets.STAGING_URL }}
        
        # Test API endpoints
        curl -f $STAGING_URL/api/healthz
        curl -f $STAGING_URL/api/fhir/Patient
        
        # Test web interface
        curl -f $STAGING_URL/

    - name: Notify deployment success
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        message: 'Staging deployment successful: ${{ github.sha }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Notify deployment failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        message: 'Staging deployment failed: ${{ github.sha }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Deploy to production environment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment: production
    concurrency: production
    needs: [deploy-staging]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get release version
      id: version
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        else
          echo "version=manual-${{ github.sha }}" >> $GITHUB_OUTPUT
        fi

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push production Docker images
      run: |
        # Build and push all service images with production tags
        for service in api web jobs; do
          docker build \
            --file infra/dockerfiles/Dockerfile.$service \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/emr-$service:production \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/emr-$service:${{ steps.version.outputs.version }} \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/emr-$service:latest \
            --push \
            .
        done

    - name: Create deployment backup
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USERNAME }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          # Create backup of current deployment
          cd /opt/emr-platform
          
          # Backup database
          docker exec emr-postgres pg_dump -U emr_user emr_platform > backup-$(date +%Y%m%d-%H%M%S).sql
          
          # Backup configuration
          tar -czf config-backup-$(date +%Y%m%d-%H%M%S).tar.gz docker-compose.yml .env* nginx/ certs/

    - name: Deploy to production
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USERNAME }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          # Update deployment configuration
          cd /opt/emr-platform
          
          # Pull latest images
          docker compose --profile production pull
          
          # Update environment variables
          echo "IMAGE_TAG=production" > .env.production
          echo "DEPLOYMENT_ENV=production" >> .env.production
          echo "VERSION=${{ steps.version.outputs.version }}" >> .env.production
          
          # Rolling deployment with health checks
          docker compose --profile production up -d --remove-orphans --scale api=2
          
          # Wait for new instances to be healthy
          sleep 60
          
          # Health check
          curl -f https://emr.yourdomain.com/api/healthz || exit 1
          curl -f https://emr.yourdomain.com/api/health || exit 1
          
          # Scale back to normal
          docker compose --profile production up -d --remove-orphans
          
          # Clean up old images
          docker image prune -f

    - name: Run production smoke tests
      run: |
        # Run critical smoke tests against production
        export PRODUCTION_URL=${{ secrets.PRODUCTION_URL }}
        
        # Test critical endpoints
        curl -f $PRODUCTION_URL/api/healthz
        curl -f $PRODUCTION_URL/api/fhir/metadata
        
        # Test authentication
        curl -f $PRODUCTION_URL/auth/login
        
        # Test web interface
        curl -f $PRODUCTION_URL/

    - name: Update monitoring and alerts
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.MONITORING_HOST }}
        username: ${{ secrets.MONITORING_USERNAME }}
        key: ${{ secrets.MONITORING_SSH_KEY }}
        port: ${{ secrets.MONITORING_PORT }}
        script: |
          # Update monitoring configuration
          cd /opt/monitoring
          
          # Reload Prometheus configuration
          curl -X POST http://localhost:9090/-/reload
          
          # Update Grafana dashboards
          curl -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.GRAFANA_API_KEY }}" \
            http://localhost:3000/api/dashboards/db \
            -d @emr-dashboard.json

    - name: Create GitHub release
      if: startsWith(github.ref, 'refs/tags/v')
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.version.outputs.version }}
        name: Release ${{ steps.version.outputs.version }}
        body: |
          ## Changes in this release
          
          - Deployed to production at $(date)
          - Docker images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/emr-*:${{ steps.version.outputs.version }}
          
          ## Health Status
          
          - API: âœ… Healthy
          - Web: âœ… Healthy  
          - Jobs: âœ… Healthy
          - Database: âœ… Healthy
          
          ## Deployment Details
          
          - Commit: ${{ github.sha }}
          - Environment: production
          - Deployed by: ${{ github.actor }}
        draft: false
        prerelease: false

    - name: Notify production deployment success
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        message: |
          ðŸš€ Production deployment successful!
          
          Version: ${{ steps.version.outputs.version }}
          Commit: ${{ github.sha }}
          Deployed by: ${{ github.actor }}
          
          All systems operational âœ…
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Notify production deployment failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        message: |
          âŒ Production deployment failed!
          
          Version: ${{ steps.version.outputs.version }}
          Commit: ${{ github.sha }}
          
          Please investigate immediately.
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Rollback workflow
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure()
    environment: production
    
    steps:
    - name: Rollback production deployment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USERNAME }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          # Rollback to previous version
          cd /opt/emr-platform
          
          # Get previous version
          PREVIOUS_VERSION=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep emr-api | grep -v latest | head -2 | tail -1 | cut -d: -f2)
          
          # Update to previous version
          echo "IMAGE_TAG=$PREVIOUS_VERSION" > .env.production
          
          # Deploy previous version
          docker compose --profile production up -d --remove-orphans
          
          # Wait for rollback to complete
          sleep 30
          
          # Health check
          curl -f https://emr.yourdomain.com/api/healthz || exit 1

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            "channel": "#deployments",
            "text": "ðŸ”„ Production deployment rolled back due to failure",
            "color": "warning"
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} 